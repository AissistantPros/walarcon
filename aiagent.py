# aiagent.py
# -*- coding: utf-8 -*-
"""
aiagent ‚Äì motor de decisi√≥n para la asistente telef√≥nica
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
‚Ä¢ √önico modelo ‚Üí gpt-4.1-mini (o el que est√©s usando)
‚Ä¢ Flujos main / edit / delete con redirecciones internas
‚Ä¢ Nueva "s√∫per herramienta" process_appointment_request
‚Ä¢ M√©tricas de latencia (üïí ms) en todos los pases Chat-GPT
‚Ä¢ Logging DEBUG uniforme (cambia LOG_LEVEL a INFO en producci√≥n)
"""

from __future__ import annotations

import json
import logging
from time import perf_counter
from typing import Dict, List, Any # A√±adido Any para el tipado de retorno de handle_tool_execution
from decouple import config
from openai import OpenAI


# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ CONFIG LOGGING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
LOG_LEVEL = logging.DEBUG # ‚á¢ INFO en prod.
logging.basicConfig(
    level=LOG_LEVEL,
    format="%(asctime)s | %(levelname)5s | %(name)s: %(message)s",
    datefmt="%H:%M:%S",
)
logger = logging.getLogger("aiagent")

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ OPENAI CLIENT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
# Aseg√∫rate que CHATGPT_SECRET_KEY est√© en tu .env o configuraci√≥n
try:
    client = OpenAI(api_key=config("CHATGPT_SECRET_KEY"))
except Exception as e:
    logger.critical(f"No se pudo inicializar el cliente OpenAI. Verifica CHATGPT_SECRET_KEY: {e}")
    # Podr√≠as querer que el sistema falle aqu√≠ si OpenAI es esencial.
    # raise SystemExit("Fallo al inicializar OpenAI client.") from e # Descomenta para fallar

# ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ IMPORTS DE TOOLS DE NEGOCIO ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
import buscarslot
from utils import search_calendar_event_by_phone # Sigue siendo necesaria para editar/eliminar
from consultarinfo import get_consultorio_data_from_cache
from crearcita import create_calendar_event
from editarcita import edit_calendar_event # Asumo que estas existen
from eliminarcita import delete_calendar_event # Asumo que estas existen

# prompt din√°mico (system)
from prompt import generate_openai_prompt # Aseg√∫rate que el nombre del archivo prompt.py sea correcto

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê HELPERS ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
def _t(start: float) -> str:
    """Devuelve el tiempo transcurrido desde *start* en ms formateado."""
    return f"{(perf_counter() - start) * 1_000:6.1f} ms"


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê UNIFIED TOOLS DEFINITION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Esta es la √öNICA lista de herramientas que necesitar√°s.
# Contiene TODAS las herramientas que la IA podr√≠a usar,
# guiada por el system_prompt de prompt.py.
TOOLS = [
    {
        "type": "function",
        "function": {
            "name": "read_sheet_data",
            "description": "Obtener informaci√≥n general del consultorio como direcci√≥n, horarios de atenci√≥n general, servicios principales, o pol√≠ticas de cancelaci√≥n. No usar para verificar disponibilidad de citas."
            # No necesita par√°metros expl√≠citos aqu√≠ si la funci√≥n Python usa defaults
        }
    },
    {
        "type": "function",
        "function": {
            "name": "process_appointment_request",
            "description": (
                "Procesa la solicitud de agendamiento o consulta de disponibilidad de citas. "
                "Interpreta la petici√≥n de fecha/hora del usuario (ej. 'pr√≥xima semana', 'el 15 a las 10', 'esta semana en la tarde', 'lo m√°s pronto posible') "
                "y busca un slot disponible en el calendario que cumpla con los criterios. "
                "Devuelve un slot encontrado, un mensaje si no hay disponibilidad, o pide aclaraci√≥n si la fecha es ambigua o conflictiva."
            ),
            "parameters": {
                "type": "object",
                "properties": {
                    "user_query_for_date_time": {
                        "type": "string",
                        "description": "La frase textual completa del usuario referente a la fecha y/o hora deseada. Ej: 'quiero una cita para el pr√≥ximo martes por la tarde', '¬øtienes algo para el 15 de mayo a las 10 am?', 'lo m√°s pronto posible'."
                    },
                    "day_param": {"type": "integer", "description": "D√≠a num√©rico del mes si el usuario lo menciona expl√≠citamente (ej. 15 para 'el 15 de mayo'). Opcional."},
                    "month_param": {"type": ["string", "integer"], "description": "Mes, como nombre (ej. 'mayo', 'enero') o n√∫mero (ej. 5, 1) si el usuario lo menciona. Opcional."},
                    "year_param": {"type": "integer", "description": "A√±o si el usuario lo especifica (ej. 2025). Opcional, si no se da, se asume el actual o el siguiente si la fecha es pasada."},
                    "fixed_weekday_param": {"type": "string", "description": "D√≠a de la semana solicitado por el usuario (ej. 'lunes', 'martes'). Opcional."},
                    "explicit_time_preference_param": {"type": "string", "description": "Preferencia expl√≠cita de franja horaria como 'ma√±ana', 'tarde' o 'mediodia', si el usuario la indica claramente. Opcional.", "enum": ["ma√±ana", "tarde", "mediodia"]},
                    "is_urgent_param": {"type": "boolean", "description": "Poner a True si el usuario indica urgencia o quiere la cita 'lo m√°s pronto posible', 'cuanto antes', etc. Esto priorizar√° la b√∫squeda inmediata. Opcional, default False."},
                    "more_late_param": {"type": "boolean", "description": "Cuando el usuario pide ‚Äòm√°s tarde‚Äô despu√©s de ofrecerle un horario. Opcional."},
                    "more_early_param": {"type": "boolean", "description": "Cuando el usuario pide ‚Äòm√°s temprano‚Äô despu√©s de ofrecerle un horario. Opcional."}
                },
                "required": ["user_query_for_date_time"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "create_calendar_event",
            "description": "Crear una nueva cita m√©dica en el calendario DESPU√âS de que el usuario haya confirmado un slot espec√≠fico, nombre, tel√©fono y motivo.",
            "parameters": {
                "type": "object",
                "properties": {
                    "name": {"type": "string", "description": "Nombre completo del paciente."},
                    "phone": {"type": "string", "description": "N√∫mero de tel√©fono del paciente (10 d√≠gitos)."},
                    "reason": {"type": "string", "description": "Motivo de la consulta."},
                    "start_time": {"type": "string", "format": "date-time", "description": "Hora de inicio de la cita en formato ISO8601 con offset (ej. YYYY-MM-DDTHH:MM:SS-05:00). Obtenido de 'process_appointment_request'."},
                    "end_time": {"type": "string", "format": "date-time", "description": "Hora de fin de la cita en formato ISO8601 con offset. Obtenido de 'process_appointment_request'."}
                },
                "required": ["name", "phone", "start_time", "end_time"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "search_calendar_event_by_phone",
            "description": "Buscar citas existentes de un paciente por su n√∫mero de tel√©fono para poder modificarlas o cancelarlas.",
            "parameters": {
                "type": "object",
                "properties": {"phone": {"type": "string", "description": "N√∫mero de tel√©fono del paciente (10 d√≠gitos)."}},
                "required": ["phone"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "edit_calendar_event",
            "description": "Modificar una cita existente en el calendario. Requiere el ID del evento, la hora de inicio original, y los nuevos detalles de fecha/hora. Opcionalmente puede actualizar nombre, motivo o tel√©fono en la descripci√≥n.",
            "parameters": {
                "type": "object",
                "properties": {
                    "event_id": {"type": "string", "description": "El ID del evento de calendario a modificar. Obtenido de 'search_calendar_event_by_phone'."},
                    "original_start_time": {"type": "string", "format": "date-time", "description": "Hora de inicio original de la cita a modificar (ISO8601)."},
                    "new_start_time": {"type": "string", "format": "date-time", "description": "Nueva hora de inicio para la cita (ISO8601). Obtenida de 'process_appointment_request'."},
                    "new_end_time": {"type": "string", "format": "date-time", "description": "Nueva hora de fin para la cita (ISO8601). Obtenida de 'process_appointment_request'."},
                    "new_name": {"type": "string", "description": "Opcional. Nuevo nombre del paciente si el usuario desea cambiarlo."},
                    "new_reason": {"type": "string", "description": "Opcional. Nuevo motivo de la consulta si el usuario desea cambiarlo."},
                    "new_phone_for_description": {"type": "string", "description": "Opcional. Nuevo tel√©fono para la descripci√≥n de la cita si el usuario desea cambiarlo."}
                },
                "required": ["event_id", "original_start_time", "new_start_time", "new_end_time"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "delete_calendar_event",
            "description": "Eliminar/Cancelar una cita existente del calendario.",
            "parameters": {
                "type": "object",
                "properties": {
                    "event_id": {"type": "string", "description": "El ID del evento de calendario a eliminar. Obtenido de 'search_calendar_event_by_phone'."},
                    "original_start_time": {"type": "string", "format": "date-time", "description": "Hora de inicio original de la cita a eliminar (ISO8601), para confirmaci√≥n."}
                },
                "required": ["event_id", "original_start_time"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "detect_intent",
            "description": "Detecta la intenci√≥n principal del usuario cuando no est√° claro si quiere agendar una nueva cita, o si cambia de opini√≥n hacia modificar o cancelar una cita existente, o si pide 'm√°s tarde' o 'm√°s temprano' un horario.",
            "parameters": {
                "type": "object",
                "properties": {
                    "intention": {
                        "type": "string",
                        "enum": ["create", "edit", "delete", "informational", "unknown", "more_late", "more_early"],
                        "description": "La intenci√≥n detectada del usuario."
                    }
                },
                "required": ["intention"]
            }
        }
    },
    {
        "type": "function",
        "function": {
            "name": "end_call",
            "description": "Finaliza la llamada telef√≥nica. Usar solo cuando la conversaci√≥n ha concluido natural o infructuosamente, o si el usuario lo pide.",
            "parameters": {
                "type": "object",
                "properties": {
                    "reason": {
                        "type": "string",
                        "enum": ["user_request", "task_completed", "task_failed", "silence", "spam", "time_limit", "error", "no_slot_accepted"],
                        "description": "Raz√≥n por la que se finaliza la llamada."
                    }
                },
                "required": ["reason"]
            }
        }
    }
]

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê TOOL EXECUTOR ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# (Esta funci√≥n se mantiene pr√°cticamente igual, solo aseg√∫rate que los nombres
# de las funciones coincidan con los definidos en TOOLS y los imports)
def handle_tool_execution(tc: Any) -> Dict[str, Any]: # tc es un ToolCall object de OpenAI
    fn_name = tc.function.name
    try:
        args = json.loads(tc.function.arguments or "{}")
    except json.JSONDecodeError:
        logger.error(f"Error al decodificar argumentos JSON para {fn_name}: {tc.function.arguments}")
        return {"error": f"Argumentos inv√°lidos para {fn_name}"}
        
    logger.debug("üõ†Ô∏è Ejecutando herramienta: %s con args: %s", fn_name, args)

    try:
        if fn_name == "read_sheet_data":
            return {"data_consultorio": get_consultorio_data_from_cache()}
        elif fn_name == "process_appointment_request":
            return buscarslot.process_appointment_request(**args) #
        elif fn_name == "create_calendar_event":
            phone = args.get("phone", "")
            if not (phone.isdigit() and len(phone) == 10): #
                logger.warning(f"Tel√©fono inv√°lido '{phone}' para crear evento. La IA deber√≠a haberlo validado.")
                return {"error": "Tel√©fono inv√°lido proporcionado para crear la cita. Debe tener 10 d√≠gitos."}
            return create_calendar_event(**args) #
        elif fn_name == "edit_calendar_event":
            return edit_calendar_event(**args) #
        elif fn_name == "delete_calendar_event":
            return delete_calendar_event(**args) #
        elif fn_name == "search_calendar_event_by_phone":
            return {"search_results": search_calendar_event_by_phone(**args)} #
        elif fn_name == "detect_intent":
            # Simplemente devuelve la intenci√≥n detectada por la IA
            # El system_prompt guiar√° al modelo sobre c√≥mo actuar con esta informaci√≥n.
            return {"intent_detected": args.get("intention")}
        elif fn_name == "end_call":
            return {"call_ended_reason": args.get("reason", "unknown")}
        else:
            logger.warning(f"Funci√≥n {fn_name} no reconocida en handle_tool_execution.")
            return {"error": f"Funci√≥n desconocida: {fn_name}"}

    except Exception as e:
        logger.exception("Error cr√≠tico durante la ejecuci√≥n de la herramienta %s", fn_name)
        return {"error": f"Error interno al ejecutar {fn_name}: {str(e)}"}

# ... (todo el c√≥digo anterior, incluyendo la lista TOOLS y handle_tool_execution)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê CORE ‚Äì UNIFIED RESPONSE GENERATION ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# Esta es ahora la √öNICA funci√≥n que necesitas para generar respuestas de OpenAI.
async def generate_openai_response_main(history: List[Dict], model: str = "gpt-4.1-mini") -> str: #
    try:
        full_conversation_history = generate_openai_prompt(list(history)) #

        t1_start = perf_counter()
        logger.debug("OpenAI Unified Flow - Pase 1: Enviando a %s", model)

        if not client:
            logger.error("Cliente OpenAI no inicializado. Abortando generate_openai_response_main.")
            return "Lo siento, estoy teniendo problemas t√©cnicos para conectarme. Por favor, intente m√°s tarde."

        response_pase1 = client.chat.completions.create(
            model=model,
            messages=full_conversation_history,
            tools=TOOLS, 
            tool_choice="auto",
            max_tokens=150, 
            temperature=0.2, # <- Este es el valor que usa tu √∫ltima versi√≥n
            timeout=15, 
        ).choices[0].message

        logger.debug("üïí OpenAI Unified Flow - Pase 1 completado en %s", _t(t1_start))

        if not response_pase1.tool_calls:
            logger.debug("OpenAI Unified Flow - Pase 1: Respuesta directa de la IA: %s", response_pase1.content)
            return response_pase1.content or "No he podido procesar su solicitud en este momento."

        full_conversation_history.append(response_pase1.model_dump()) 

        tool_messages_for_pase2 = []
        for tool_call in response_pase1.tool_calls:
            tool_call_id = tool_call.id
            function_result = handle_tool_execution(tool_call)

            if function_result.get("call_ended_reason"):
                logger.info("Solicitud de finalizar llamada recibida desde ejecuci√≥n de herramienta: %s", function_result["call_ended_reason"])
                return "__END_CALL__"

            tool_messages_for_pase2.append({
                "tool_call_id": tool_call_id,
                "role": "tool",
                "name": tool_call.function.name,
                "content": json.dumps(function_result), 
            })

        full_conversation_history.extend(tool_messages_for_pase2)

        t2_start = perf_counter()
        logger.debug("OpenAI Unified Flow - Pase 2: Enviando a %s con resultados de herramientas.", model)

        response_pase2 = client.chat.completions.create(
            model=model,
            messages=full_conversation_history,
            tools=TOOLS, 
            tool_choice="auto",
            # max_tokens=250, # Puedes descomentar y ajustar si necesitas respuestas m√°s largas aqu√≠
            # temperature=0.2, # Ya est√° definido en el Pase 1, usualmente no se repite aqu√≠ a menos que quieras un comportamiento distinto para el Pase 2
        ).choices[0].message
        logger.debug("üïí OpenAI Unified Flow - Pase 2 completado en %s", _t(t2_start))

        logger.debug("OpenAI Unified Flow - Pase 2: Respuesta final de la IA: %s", response_pase2.content)
        return response_pase2.content or "No tengo una respuesta en este momento."

    except Exception as e:
        logger.exception("generate_openai_response_main fall√≥ gravemente")
        return "Lo siento mucho, estoy experimentando un problema t√©cnico y no puedo continuar. Por favor, intente llamar m√°s tarde."
